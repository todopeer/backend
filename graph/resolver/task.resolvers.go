package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
	"context"

	"github.com/Shopify/hoff"
	"github.com/jinzhu/gorm"
	"github.com/todopeer/backend/graph"
	"github.com/todopeer/backend/graph/model"
	"github.com/todopeer/backend/orm"
	"github.com/todopeer/backend/services/auth"
)

// TaskCreate is the resolver for the taskCreate field.
func (r *mutationResolver) TaskCreate(ctx context.Context, input model.TaskCreateInput) (*model.Task, error) {
	user := auth.UserFromContext(ctx)

	status := orm.TaskStatusNotStarted
	dbTask := &orm.Task{
		Name:        &input.Name,
		UserID:      &user.ID,
		Description: input.Description,
		Status:      &status,
		DueDate:     input.DueDate,
	}

	if err := r.taskOrm.CreateTask(dbTask); err != nil {
		return nil, err
	}

	return model.ConvertToGqlTaskModel(dbTask), nil
}

// TaskUpdate is the resolver for the taskUpdate field.
func (r *mutationResolver) TaskUpdate(ctx context.Context, id int64, input model.TaskUpdateInput) (*model.Task, error) {
	user := auth.UserFromContext(ctx)
	task, err := r.taskOrm.GetTaskByID(id)
	if err != nil {
		return nil, err
	}
	if task == nil {
		return nil, ErrNotFound
	}

	if *task.UserID != user.ID {
		return nil, ErrUnauthorized
	}

	changes := input.ChangesAsTask()
	if err := r.taskOrm.UpdateTask(task, changes, user); err != nil {
		return nil, err
	}

	return model.ConvertToGqlTaskModel(task), nil
}

// TaskRemove is the resolver for the taskRemove field.
func (r *mutationResolver) TaskRemove(ctx context.Context, id int64) (*model.Task, error) {
	user := auth.UserFromContext(ctx)
	task, err := r.taskOrm.GetTaskByID(id)
	if err != nil {
		return nil, err
	}
	if task == nil {
		return nil, gorm.ErrRecordNotFound
	}

	if *task.UserID != user.ID {
		return nil, ErrUnauthorized
	}

	err = r.taskOrm.DeleteTask(task, user)
	if err != nil {
		return nil, err
	}

	return model.ConvertToGqlTaskModel(task), nil
}

// Tasks is the resolver for the tasks field.
func (r *queryResolver) Tasks(ctx context.Context, input model.QueryTaskInput) ([]*model.Task, error) {
	user := auth.UserFromContext(ctx)

	var options []orm.QueryTaskOptionFunc
	if len(input.Status) > 0 {
		statuses := hoff.Map(input.Status, model.TaskStatusToInt)
		options = append(options, orm.GetTasksWithStatus(statuses))
	}

	if input.OrderBy != nil {
		options = append(options, orm.GetTasksWithOrder(string(input.OrderBy.Field), (*string)(input.OrderBy.Direction)))
	}

	dbTasks, err := r.taskOrm.GetTasksByUserID(user.ID, options...)
	if err != nil {
		return nil, err
	}

	var tasks []*model.Task
	for _, dbTask := range dbTasks {
		task := model.ConvertToGqlTaskModel(dbTask)
		tasks = append(tasks, task)
	}

	return tasks, nil
}

// Task is the resolver for the task field.
func (r *queryResolver) Task(ctx context.Context, id int64) (*model.Task, error) {
	user := auth.UserFromContext(ctx)
	task, err := r.taskOrm.GetTaskByID(id)
	if err != nil {
		return nil, err
	}
	if task == nil {
		return nil, ErrNotFound
	}

	if user.ID != *task.UserID {
		// TODO: make this error common
		return nil, ErrUnauthorized
	}

	taskInGQL := model.ConvertToGqlTaskModel(task)
	return taskInGQL, nil
}

// UserTasks is the resolver for the userTasks field.
func (r *queryResolver) UserTasks(ctx context.Context, username string) (*model.QueryUserTaskResult, error) {
	user, err := r.userORM.GetUserByUsername(ctx, username)
	if err != nil {
		return nil, err
	}

	// load task under this user
	tasks, err := r.taskOrm.GetTasksByUserID(user.ID)
	if err != nil {
		return nil, err
	}
	taskResp := hoff.Map(tasks, model.ConvertToGqlTaskModel)

	res := &model.QueryUserTaskResult{
		User:  model.ConvertToGqlPublicUserModel(user),
		Tasks: taskResp,
	}

	if user.RunningTaskID != nil {
		runningTasks := hoff.Filter(taskResp, func(t *model.Task) bool {
			return t.ID == *user.RunningTaskID
		})
		if len(runningTasks) > 0 {
			res.Doing = taskResp[0]
		}
	}
	return res, nil
}

// Events is the resolver for the events field.
func (r *taskResolver) Events(ctx context.Context, obj *model.Task, input *model.TaskEventQueryInput) ([]*model.Event, error) {
	var options []orm.EventOptionFunc
	if input != nil {
		if input.Limit != nil {
			options = append(options, orm.EventQueryOptionWithLimit(int(*input.Limit)))
		}
		if input.OrderAsc != nil {
			options = append(options, orm.EventQueryOptionWithOrderAsc(*input.OrderAsc))
		}
	}
	events, err := r.eventOrm.GetEventsByTaskID(obj.ID, options...)
	if err != nil {
		return nil, err
	}
	return hoff.Map(events, model.ConvertToGqlEventModel), nil
}

// Task returns graph.TaskResolver implementation.
func (r *Resolver) Task() graph.TaskResolver { return &taskResolver{r} }

type taskResolver struct{ *Resolver }
